input {
	beats {
		port => 5044
	}

	tcp {
		port => 5000
	}

	stdin {
		codec => multiline {
			pattern => "fin"
			negate => "true"
			what => "next"
		}
	}
}

filter {
	grok {
	match => { "message" => ["%{WORD:level} %{TIMESTAMP_ISO8601:date} \[%{WORD:thread}\] %{JAVACLASS:class} - %{WORD:type}\|%{NUMBER:status:int}\|%{USERNAME:user}\|%{IP:ip}",
"%{WORD:level} %{TIMESTAMP_ISO8601:date} \[%{WORD:thread}\] %{JAVACLASS:class} - %{WORD:type}\|%{NUMBER:duration:int}\|%{DATA:action}\|%{WORD:status}\|%{USERNAME:user}",
"(?m)%{WORD:level} %{TIMESTAMP_ISO8601:date} \[%{WORD:thread}\] %{JAVACLASS:class} - %{DATA:description}\|%{GREEDYDATA:stacktrace}"] }
	}

	mutate {
		# convert => {"duration" => "integer"}
		remove_field => ["message","prospector","input"]
		rename => {"@timestamp" => "processTime"}
	}

	if ![type] {
		mutate{
			add_field => {"type" => "JAVA_ERROR"}
		}
	}

	if [type] == "LOGIN" {
		mutate{
			# convert => {"status" => "integer"}
			add_field => {"login" => true}
		}

		if [status] >300 { 
			mutate{
				replace => {"login" => false}
			}
		}

		translate { 
			field => "status"
			destination => "statusText"
			dictionary =>{
				"200" => "Login Correcto"
				"201" => "Login correcto tras varios intentos"	
				"202" => "Login incorrecto con actualizaciÃ³n de password"
				"204" => "Login automatico"
				"250" => "Login recordado"
				"100" => "Usuario suplantado"
				"150" => "Usuario suplantado automaticamente"
				"400" => "Usuario bloqueado"
				"404" => "Usuario no encontrado"
				"500" => "ContraseÃ±a expirada"
			}
		}

		# geoip {
		# 	source => "ip"
		# }
	}	

	date {
		match => ["date","YYYY-MM-dd HH:mm:ss"]
	}
	
}

## Add your filters / logstash plugins configuration here

output {
	elasticsearch {
		hosts => "elasticsearch:9200"
		user => "elastic"
		password => "changeme"
		ecs_compatibility => disabled
	}

    stdout {}

}
